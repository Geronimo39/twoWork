import pyodbc
import pandas as pd
import os
import datetime

# --- KONFIGURATION ---------------------------------------------------------
SYSTEM_NAME = 'DEINE_AS400_IP'
USER = 'DEIN_USER'
PWD  = 'DEIN_PASSWORT'

# Deine Bibliothek (jetzt mit Schreibrechten!)
TARGET_LIB = 'DEINE_NEUE_LIB' 
# Name der finalen Ergebnistabelle
TARGET_TABLE = 'JAVA_INVENTORY'

# Suchpfade und Endungen
SEARCH_PATHS = ['/home', '/QOpenSys'] 
EXTENSIONS = ['*.java', '*.jar', '*.class', '*.json', '*.xml', '*.properties', '*.war']
# ---------------------------------------------------------------------------

def connect_db():
    # Wir brauchen jetzt keine Tricks mehr im Connection String
    conn_str = f'DRIVER={{IBM i Access ODBC Driver}};SYSTEM={SYSTEM_NAME};UID={USER};PWD={PWD};'
    return pyodbc.connect(conn_str, autocommit=True)

def setup_database(cursor):
    """Erstellt eine saubere SQL-Tabelle für die Ergebnisse"""
    table_fq = f"{TARGET_LIB}.{TARGET_TABLE}"
    
    print(f"Prüfe Zieltabelle: {table_fq}...")
    
    # Tabelle neu erstellen (Clean Slate Strategy)
    try:
        cursor.execute(f"DROP TABLE {table_fq}")
    except:
        pass # Gab es noch nicht

    # Eine echte relationale Tabelle erstellen
    create_sql = f"""
        CREATE TABLE {table_fq} (
            ID INT GENERATED ALWAYS AS IDENTITY,
            SCAN_TIMESTAMP TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FULL_PATH VARCHAR(1000),
            FILENAME VARCHAR(255),
            EXTENSION VARCHAR(20),
            ROOT_DIR VARCHAR(100)
        )
    """
    cursor.execute(create_sql)
    print("   [OK] Tabelle für Ergebnisse frisch erstellt.")

def run_official_hunt():
    conn = connect_db()
    if not conn: return
    cursor = conn.cursor()
    
    print("--- Sherlock Java Hunter (Offizieller Modus) ---")
    
    # 1. Infrastruktur
    setup_database(cursor)
    
    # Wir brauchen EINEN temporären "Eimer" für den QShell-Output,
    # da wir auf dem alten OS die Dateiliste nicht direkt in eine Variable kriegen.
    # Das ist aber nur temporär.
    temp_file = f"{TARGET_LIB}/RAW_FIND"
    try:
        cursor.execute(f"CALL QSYS2.QCMDEXC('CRTSRCPF FILE({temp_file}) RCDLEN(1000) MBR(LISTE)')")
    except:
        cursor.execute(f"CALL QSYS2.QCMDEXC('CLRPFM FILE({temp_file}) MBR(LISTE)')")

    # 2. Scannen (Sammeln)
    print("Starte Scan-Vorgang...")
    total_findings = 0
    
    for path in SEARCH_PATHS:
        for ext in EXTENSIONS:
            print(f"   Suche in {path} nach {ext} ...")
            
            # QShell schreibt in den Temp-Eimer
            qsys_path = f"/qsys.lib/{TARGET_LIB}.lib/RAW_FIND.file/LISTE.mbr"
            unix_cmd = f"find {path} -name '{ext}' >> {qsys_path} 2> /dev/null"
            cl_cmd = f"QSH CMD('{unix_cmd.replace(chr(39), chr(39)*2)}')"
            
            try:
                # Environment Variable setzen um Abstürze zu vermeiden (Best Practice)
                cursor.execute("CALL QSYS2.QCMDEXC('ADDENVVAR ENVVAR(QIBM_QSH_CMD_OUTPUT) VALUE(NONE) LEVEL(*JOB) REPLACE(*YES)')")
                cursor.execute(f"CALL QSYS2.QCMDEXC('{cl_cmd}')")
            except Exception as e:
                print(f"   Warnung bei {path}: {e}")

    # 3. Verarbeiten & Speichern (ETL Prozess)
    # Jetzt lesen wir den Temp-Eimer, bereinigen die Daten in Python 
    # und schreiben sie SAUBER via INSERT in die finale Tabelle.
    
    print("Verarbeite Rohdaten und speichere in SQL-Tabelle...")
    
    # Rohdaten holen
    df_raw = pd.read_sql(f"SELECT SRCDTA FROM {temp_file}", conn)
    
    if not df_raw.empty:
        # Bereinigen
        clean_paths = df_raw['SRCDTA'].str.strip()
        clean_paths = clean_paths[clean_paths.str.startswith('/')].unique()
        
        # Batch Insert vorbereiten
        insert_sql = f"""
            INSERT INTO {TARGET_LIB}.{TARGET_TABLE} 
            (FULL_PATH, FILENAME, EXTENSION, ROOT_DIR) 
            VALUES (?, ?, ?, ?)
        """
        
        data_to_insert = []
        for p in clean_paths:
            fname = os.path.basename(p)
            ext = os.path.splitext(fname)[1].upper().replace('.', '')
            root = path # Grobe Zuordnung
            data_to_insert.append((p, fname, ext, root))
            
        # Massen-Insert (Viel schneller als einzeln)
        cursor.executemany(insert_sql, data_to_insert)
        
        total_findings = len(data_to_insert)
        print(f"   [OK] {total_findings} Einträge in {TARGET_LIB}.{TARGET_TABLE} gespeichert.")
    else:
        print("   Keine Dateien gefunden.")

    # 4. Aufräumen (Temp-Datei löschen)
    # Das macht den Prozess "sauber".
    try:
        cursor.execute(f"CALL QSYS2.QCMDEXC('DLTF FILE({temp_file})')")
        print("Temp-Dateien aufgeräumt.")
    except: pass

    print("-" * 50)
    print("FERTIG.")
    print(f"Du kannst die Ergebnisse jetzt abfragen mit:")
    print(f"SELECT * FROM {TARGET_LIB}.{TARGET_TABLE}")

if __name__ == "__main__":
    run_official_hunt()
