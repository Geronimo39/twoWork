import pyodbc
import pandas as pd
import os
import time

# --- KONFIGURATION ---------------------------------------------------------
SYSTEM_NAME = 'DEINE_AS400_IP'
USER = 'DEIN_USER'
PWD  = 'DEIN_PASSWORT'

# Start-Pfade für die Suche im IFS (Unix-Dateisystem)
# '/home' ist Standard. '/QOpenSys' enthält oft OpenSource/Java.
# Wenn du mutig bist und Zeit hast: '/' (Root)
SEARCH_PATHS = ['/home', '/QOpenSys', '/www'] 

# Dateiendungen für Java & REST/Web
EXTENSIONS = ['*.java', '*.class', '*.jar', '*.war', '*.json', '*.xml', '*.properties', '*.yml']

# Bibliothek für temporäre Zwischenspeicherung (Muss existieren!)
# Nutze 'QTEMP' (wird beim Ausloggen gelöscht) oder deine 'DEINE_NEUE_LIB'
WORK_LIB = 'QTEMP' 

OUTPUT_XLS = 'Java_Rest_Inventory_Local.xlsx'
# ---------------------------------------------------------------------------

def connect_as400():
    conn_str = f'DRIVER={{IBM i Access ODBC Driver}};SYSTEM={SYSTEM_NAME};UID={USER};PWD={PWD};'
    try:
        # Read-Only Modus (oft schneller und sicherer)
        return pyodbc.connect(conn_str, autocommit=True, readOnly=True)
    except Exception as e:
        print(f"Verbindungsfehler: {e}")
        return None

def run_local_hunt():
    conn = connect_as400()
    if not conn: return
    cursor = conn.cursor()
    
    print(f"--- Sherlock Java & REST Hunter (Local Storage) ---")
    print("Strategie: Ergebnisse werden lokal gespeichert (umgeht Exit-Programm).")

    all_findings = []

    try:
        # 1. Container vorbereiten (einmalig)
        # Wir erstellen eine Datei in QTEMP/WORK_LIB, um die Suchergebnisse aufzufangen.
        # Das ist kein ODBC-Insert, sondern ein Systembefehl -> sollte erlaubt sein.
        print(f"1. Bereite Auffang-Container in {WORK_LIB} vor...")
        try:
            # Datei erstellen (breit genug für lange Pfade)
            cmd_crt = f"CRTSRCPF FILE({WORK_LIB}/JAVA_FIND) RCDLEN(1000) MBR(LISTE)"
            cursor.execute(f"CALL QSYS2.QCMDEXC('{cmd_crt}')")
        except:
            # Datei existiert wohl schon, wir leeren sie
            try: cursor.execute(f"CALL QSYS2.QCMDEXC('CLRPFM FILE({WORK_LIB}/JAVA_FIND)')")
            except: pass

        # 2. Suchen (Schleife über Pfade und Endungen)
        print("2. Starte Suche im IFS (QShell)...")
        
        for path in SEARCH_PATHS:
            for ext in EXTENSIONS:
                print(f"   Scanne {path} nach {ext} ...")
                
                # Der Unix-Befehl 'find' schreibt direkt in die DB2-Datei.
                # Das ist ein AS400-interner Schreibvorgang, kein externer ODBC-Insert!
                # Syntax: find /pfad -name "*.java" > /qsys.lib/LIB.lib/FILE.file/MBR.mbr
                
                db2_target = f"/qsys.lib/{WORK_LIB}.lib/JAVA_FIND.file/LISTE.mbr"
                # '>>' hängt an (Append), damit wir vorherige Treffer nicht überschreiben
                unix_cmd = f"find {path} -name '{ext}' >> {db2_target} 2> /dev/null"
                
                # Escaping für CL (Hochkommas verdoppeln)
                cl_cmd = f"QSH CMD('{unix_cmd.replace(chr(39), chr(39)*2)}')"
                
                try:
                    # Wir ignorieren den Output von QSH, um Kernel-Crash zu vermeiden
                    # (Environment Variable Trick aus unserer früheren Session)
                    cursor.execute(f"CALL QSYS2.QCMDEXC('ADDENVVAR ENVVAR(QIBM_QSH_CMD_OUTPUT) VALUE(NONE) LEVEL(*JOB) REPLACE(*YES)')")
                    
                    cursor.execute(f"CALL QSYS2.QCMDEXC('{cl_cmd}')")
                except Exception as e:
                    print(f"   Fehler bei Pfad {path}: {e}")

        # 3. Ergebnisse abholen (Das ist ein SELECT -> Erlaubt!)
        print("3. Lade Ergebnisse herunter...")
        sql = f"SELECT SRCDTA FROM {WORK_LIB}.JAVA_FIND"
        df = pd.read_sql(sql, conn)
        
        if not df.empty:
            # Spalte umbenennen und bereinigen
            df.columns = ['Full_Path']
            df['Full_Path'] = df['Full_Path'].str.strip()
            
            # Filtern: Nur echte Pfade (beginnen mit /)
            df = df[df['Full_Path'].str.startswith('/')]
            
            # Zusatzinfos extrahieren (Dateiname, Endung, Ordner)
            df['Dateiname'] = df['Full_Path'].apply(os.path.basename)
            df['Typ'] = df['Dateiname'].apply(lambda x: os.path.splitext(x)[1].upper())
            df['Ordner'] = df['Full_Path'].apply(os.path.dirname)
            
            # Duplikate entfernen
            df = df.drop_duplicates()
            
            print(f"   -> {len(df)} Dateien gefunden!")
            
            # Statistik anzeigen
            print("\nVerteilung nach Typ:")
            print(df['Typ'].value_counts().to_string())

            # 4. Speichern (Lokal auf deinem PC)
            df.to_excel(OUTPUT_XLS, index=False)
            print(f"\nFERTIG! Inventar gespeichert in: {OUTPUT_XLS}")
            
        else:
            print("Keine Dateien gefunden (oder Zugriff verweigert).")

    except Exception as e:
        print(f"Kritischer Fehler: {e}")
    finally:
        conn.close()

if __name__ == "__main__":
    run_local_hunt()
